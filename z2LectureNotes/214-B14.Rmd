# Statistics (B14, Oct-10) {#b14}

```{r 'B14', include=FALSE, cache=FALSE}
sys.source(paste0(.z$RX, "A99Knitr", ".R"), envir = knitr::knit_global())
sys.source(paste0(.z$RX, "000Packages", ".R"), envir = knitr::knit_global())
sys.source(paste0(.z$RX, "A00AllUDF", ".R"), envir = knitr::knit_global())
#invisible(lapply(f_getPathR(A09isPrime), knitr::read_chunk))
```

## Overview

- "Inferential Statistics: Hypothesis Testing"
  - [Equality in Hypothesis](#equality-b14 "b14")

## Equality in Hypothesis  {#equality-b14 .unlisted .unnumbered}

- The equality part of the expression $\{\mu \geq \mu_0 \, | \, \mu \leq \mu_0 \, | \, \mu = \mu_0\}$ \textcolor{pink}{always} appears in the null hypothesis ${H_0}$. 
  - We try to reject null, so that we can confidently accept the alternate. If the alternate is ambiguous e.g. "is greater than or equal to" then we will not be able to conclude with confidence.
- Alternative hypothesis is often what the test is attempting to establish.
  - Hence, asking whether the user is looking for evidence to support $\{\mu < \mu_0 \, | \, \mu > \mu_0 \, | \, \mu \neq \mu_0\}$ will help determine ${H_a}$


```{r 'B14D02', comment="", echo=FALSE, results='asis'}
f_getDef("1s-known-sd") #dddd
```

- test statistic
  - \@ref(eq:z-sd) $z = \frac{{\overline{x}} - {\mu}_0}{{\sigma}}$

## Example: WSES: Preprocessing

```{r 'B14-xxWSES', include=FALSE}
# #Load Data: WSES
xxWSES <- f_getObject("xxWSES", "B13-WSES.csv", "772c81252c54a3162f1f8dbd0ceb9aeb")
if(FALSE) {
  loc_src <- paste0(.z$XL, "B13-WSES.xlsx")
  aa <- read_excel(path = loc_src, sheet = excel_sheets(path = loc_src)[2])
  str(aa)
}
```

\textcolor{pink}{FILENAME:} "B13-WSES.csv"

- Assuming: Average Sales 8-million $({\mu}_0 = 8)$, Standard Deviation 2-million $({\sigma} = 2)$
- Hypothesis test to check whether the average sales value in the population is at least 8-million

```{r 'B14D01', comment="", echo=FALSE, results='asis'}
f_getDef("Hypothesis-1T-Upper-Tail")
```

\textcolor{orange}{Caution:} While importing data, for Mac users, probably it will be easier to import CSV file. However, I am not a Mac user so cannot comment on this.

### Data {.unlisted .unnumbered}

```{r 'B-'}
# #Assign to another variable for easy modification and keeping the original data as backup
bb <- xxWSES
str(bb)
```

### Rename Headers {.unlisted .unnumbered}

```{r 'B-Rename'}
# #List Column Headers
names(bb)
#
# #Rename Headers
bb_headers <- c("SN" , "RS" , "SO" , "PDT" , "INT" , "RG" , "RS1" , "PM" , "SVM" , "PP" , "JB" , "LCC")
names(bb) <- bb_headers
#
# #Verification
names(bb)
#
```

### Conversion to Factor {.unlisted .unnumbered .tabset .tabset-fade}

- From the case study, it can be seen that multiple columns are categorical (factor) or ordinal (ordered factor)

- \textcolor{pink}{Question:} What is the importance of having this kind of order factor over simple factor
  - Here order is also important. Also in future, ordered factors will be needed for some analysis
  - (Aside) Refer [Scales of Measurement](#scales-c01 "c01")
    - Simple factor (nominal) can provide only Mode whereas Ordered factor (ordinal) can provide Median also. Rank based statistical models can be applied on the ordinal data.
- \textcolor{pink}{Question:} If 'RS' is already integer 0 & 1, then why convert it to factor
  - While the data shows them as 0 & 1 but actually they are NOT integers
  - If we show male and female as 0 & 1, these are still categorical
- \textcolor{pink}{Question:} Why LCC is NOT ordinal (Aside)
  - Unknown "ForLater"

#### Data {.unlisted .unnumbered}

```{r 'B-'}
# #"Reporting Status i.e. RS" Converting "character" to "factor" and Label them
bb$RS <- factor(bb$RS, levels = c("Lost", "Won"), labels = c("0", "1"))
#
# #"Sales Outcome i.e. SO" Converting "numeric" to "factor" 
bb$SO <- factor(bb$SO)
#
# #"Product Vertical i.e. PDT" Ordinal
# #What are the unique values in this column
unique(bb$PDT)
#
# #Converting "character" to "Ordered factor"
# #Note: If level order is not provided, by default, alphabatical ordering will be assigned.
levels(factor(bb$PDT, ordered = TRUE))
#
# #Provide ordering of factor levels in Ascending Order.
bb$PDT <- factor(bb$PDT, ordered = TRUE, 
      levels = c("GTMSys", "Procsys", "LearnSys", "Finsys", "Lifesys", "Logissys", "ContactSys"))
#
# #"Industry i.e. INT" Ordinal
bb$INT <- factor(bb$INT, ordered = TRUE, 
      levels = c("Capital Markets", "Banks", "Defense", "Consumer goods", "Others", "Security", 
        "Energy", "Insurance", "Airline", "Finance", "Infrastructure", "Mobility", "Other Govt.", 
        "Govt.", "Telecom equipments", "Health", "Clinical research", "Agriculture"))
#
# #"Region i.e. RG" Ordinal
bb$RG <- factor(bb$RG, ordered = TRUE, levels = c("UK", "Other Europe", "Americas", "Africa",
                                                "India", "Japan", "Singapore", "Spain", "Canada"))
#
# #"Leads Conversion Class i.e. LCC" Ordinal, However we are going with Nominal here.
bb$LCC <- factor(bb$LCC, levels = c("E", "V", "F", "L"), labels = c(1, 2, 3, 4))
```

#### Structure after Conversion {.unlisted .unnumbered}

```{r 'B-'}
str(bb)
```

#### factor() {.unlisted .unnumbered}

- \textcolor{pink}{factor()}
  - If level order is not provided, by default, alphabatical ordering will be assigned.
  - levels are the input, labels are the output in the factor() function. 
  - A factor has only a level attribute, which is set by the labels argument in the factor() function.
  - different levels are coded as ("E", "V", "F", "L")
    - for which you want the levels to be labeled as c(1, 2, 3, 4).
    - The factor function will look for the values ("E", "V", "F", "L") convert them to numerical factor classes and add the label values to the 'level' attribute of the factor. 
    - This attribute is used to convert the internal numerical values to the correct labels. 
    - Hoever, there is no 'label' attribute. 

### Conversion to Numeric 

```{r 'B-'}
# #If there are "character" columns which should be "numeric"
if(FALSE) {
  bb$RS1 <- as.numeric(bb$RS1)
  bb$PP <- as.numeric(bb$PP)
  bb$JB <- as.numeric(bb$JB)
  # #Equivalent
  bb <- bb %>% mutate(across(c(RS1, PP, JB), as.numeric))
}
```

## WSES: Analysis

### Q1

The marketing team of WSES believes that the average sales value of the leads that they receive is at least 8 million dollars. The marketing team believes that the standard deviation of sale value is about 2 million dollars. Use an appropriate hypothesis test to check whether the average sales value in the population is at least 8 million dollars.

```{r 'B14D01', comment="", echo=FALSE, results='asis'}
f_getDef("Hypothesis-1T-Upper-Tail")
```

```{r 'B-'}
sales_mean <- mean(bb$SVM)
sales_mean
z_bb <- {mean(bb$SVM) - 8} / {2 / sqrt(1000)}
```

- Mean of "Sales Value in Million i.e. SVM"
  - ${\overline{x}} = 8.0442$
    - `mean(bb$SVM)` \textcolor{pink}{$\#\mathcal{R}$}
- $n = 1000, {\mu} = 8, {\sigma} = 2$
- $z = \frac{\overline{x} - {\mu}_0}{\sigma/\sqrt{n}} = 0.6988$
  - `{8.0442 - 8} / {2 / sqrt(1000)}` \textcolor{pink}{$\#\mathcal{R}$}
- ${}^U\!P_{z = 0.6988} = 0.2423$
  - `pnorm(q = 0.6988, lower.tail = FALSE)` \textcolor{pink}{$\#\mathcal{R}$} 

## Validation {.unlisted .unnumbered .tabset .tabset-fade}

```{r 'B14-Cleanup', include=FALSE, cache=FALSE}
f_rmExist(aa, bb, ee, hh, ii, jj, kk, ll, mm, nn, oo, rr, vv, xx, yy, zz)
```

```{r 'B14-Validation', include=TRUE, cache=FALSE}
# #SUMMARISED Packages and Objects (BOOK CHECK)
f_()
#
difftime(Sys.time(), k_start)
```

****
