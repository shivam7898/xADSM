# WIP (B30, Jan-30) {#b30}

```{r 'B30', include=FALSE, cache=FALSE}
sys.source(paste0(.z$RX, "A99Knitr", ".R"), envir = knitr::knit_global())
sys.source(paste0(.z$RX, "000Packages", ".R"), envir = knitr::knit_global())
sys.source(paste0(.z$RX, "A00AllUDF", ".R"), envir = knitr::knit_global())
#invisible(lapply(f_getPathR(A09isPrime), knitr::read_chunk))
```

## Overview

```{r 'B30-namesXL', include=FALSE, eval=FALSE}
# #Object Names for each sheet
namesXL <- c("xxB26Hdesc", "xxB26Hraw", "xxB26Hmod")
```

```{r 'B30-ImportData', include=FALSE, eval=FALSE}
for(ii in seq_along(namesXL)){
  assign(namesXL[ii], readRDS(paste0(.z$XL, namesXL[ii], ".rds")))
}
```

```{r 'B30-getKC', include=FALSE, eval=FALSE}
# #Load Data: KC House
xxB26KC <- f_getRDS(xxB26KC)
```

## Prep KC House

- About: [21613, 21]
  - One Column has 2 NA
  - Date needs to be converted
  - Integer to Categorical conversion is needed
  - yr_renovated needs to be handled 0 means no renovation - We can convert to Factor of Yes/No
  - sqft_basement - Similarly Yes/No
  - There are big area houses without any bedroom or bathroom
  - Renovated House is NOT a new house.
  - Calculate Age = Date of Sales - Year Built
  - There are 8 houses with negative age i.e. sold first completed later
  - There are 430 houses with 0 age i.e. sold in same year
  - These can happen anyway

- \textcolor{pink}{Question:} Property price are affected by location. Why we are removing lat/long
  - We are already including different types like waterfront etc.
  - It would have been better if we have rural, urban, city centre, market type categories 
  - (Aside) I do not agree specially zipcodes. We cound have identiify clusters of zipcodes.
- \textcolor{pink}{Question:} Based on description of sqft_living15, would this not cause Multicollinearity issue
  - "ForLater"
- \textcolor{pink}{Question:} Average Price over zipcode has clear distinctions
  - "ForLater"
- \textcolor{pink}{Question:} Why the age is not taken as Today
  - Price is of the date it was sold. Our analysis date does not change the price.



```{r 'B30-PrepKC', eval=FALSE}
aa <- xxB26KC
#
names(aa)
bb <- aa %>% drop_na() %>% select(-c(id, view, zipcode, lat, long)) %>% mutate(Sold = year(date), Age = Sold - yr_built) %>% relocate(Age, Sold) %>% mutate(isRenew = ifelse(yr_renovated == 0, 0, 1)) %>% relocate(isRenew) %>% rename(Beds = bedrooms, Baths = bathrooms, sqLiv = sqft_living, sqLot = sqft_lot) %>% select(-date, -Sold, -yr_renovated) %>% relocate(price)
if(FALSE) str(bb)
if(FALSE) summary(bb)
if(TRUE) head(bb)

```

## Correlation Matrix


```{r 'B30-1', eval=FALSE}
kc_zsyw <- bb %>% mutate(across(where(is.numeric), ~ as.vector(scale(.)))) 
f_wl(kc_zsyw)
```


```{r 'B30-15', eval=FALSE}
hh <- cor(kc_zsyw)
cap_hh <- paste0("Correlation Matrix") 
f_pKblM(x = hh, caption = cap_hh, negPos = c(-0.5, 0.5), dig = 3, debug = TRUE)
```

## Boxplot

```{r 'B30-BoxScaledHouse', include=FALSE, eval=FALSE}
hh <- kc_zsyl
levels(hh$Keys) <- names(kc_zsyw)
#
ttl_hh <- "Box"
cap_hh <- "C34P01"
sub_hh <- NULL 
lgd_hh  <- NULL
```

```{r 'B30-ScaleBox', eval=FALSE, include=TRUE}
# #IN: hh(Keys, Values), 
C34 <- hh %>% { ggplot(data = ., mapping = aes(x = Keys, y = Values, fill = Keys)) +
    geom_boxplot() +
    k_gglayer_box +
    scale_y_continuous(breaks = breaks_pretty()) + 
    coord_flip() +
    theme(legend.position = 'none') +
    labs(x = NULL, y = NULL, caption = cap_hh, title = ttl_hh)
}
assign(cap_hh, C34)
rm(C34)
C34P01
```

```{r 'B30-Save', eval=FALSE, include=FALSE}
loc_png <- paste0(.z$PX, "C34P01","-Houses-Box-Z", ".png")
if(!file.exists(loc_png)) {
  ggsave(loc_png, plot = C34P01, device = "png", dpi = 144) 
}
```

```{r 'B30P01', echo=FALSE, eval=FALSE, fig.cap="Houses: Boxplot (Scaled)"}
knitr::include_graphics(paste0(.z$PX, "C34P01","-Houses-Box-Z", ".png"))
```

## Outliers


```{r 'B30-2', eval=FALSE}
# #Remove anythind beyond 2 SD of Price
ii <- bb %>% filter(!(abs(price - median(price)) > 2*sd(price)))
# #Remove anythind beyond 2.5 Scaled of Price
jj <- bb %>% mutate(zPrice = scale(price)) %>% relocate(zPrice) %>% filter(between(zPrice, -2.5, +2.5))
```


```{r 'B30-3', eval=FALSE}
ii <- ii %>% select(-sqft_basement)

index_ii <- sample(1:nrow(ii), .80*nrow(ii))
train <- ii[index_ii,]
test <- ii[-index_ii,]
#
str(train)

```


```{r 'B30-4', eval=FALSE}
## run the linear regression model
model1 <- lm(price ~ ., data = train)
summary(model1)
```


```{r 'B30-5', eval=FALSE}
# #Get PRediction 
predicted <- predict(model1, newdata = test)# predict the test data
table1 <- data.frame(Actual  = test$price, Predicted = predicted)#createa  table with actual test and predictd test

```


```{r 'B30-6', eval=FALSE}
mape_test <- mean(abs(table1$Actual - table1$Predicted) / table1$Actual)
accuracy_test <- 1 - mape_test
accuracy_test
```


```{r 'B30-7', eval=FALSE}
# #Train
#custom control parameters

custom <- trainControl(method = "repeatedcv", number = 10, repeats = 5)
#
ridge <- train(price ~ ., train, method = "glmnet", 
                tuneGrid = expand.grid(alpha = 0, lambda = seq(0.0001, 1, length = 5)), 
               trControl = custom)
# #
names(ridge)
```



```{r 'B30-8', eval=FALSE}
predicted_ridge <- predict(ridge, newdata = test)# predict the test data
table_ridge <- data.frame(Actual  = test$price, Predicted = predicted_ridge)#createa  table with actual test and predictd test
str(table_ridge)
#
#
```



```{r 'B30-9', eval=FALSE}

mape_ridge <- mean(abs(table_ridge$Actual - table_ridge$Predicted) / table_ridge$Actual)
accuracy_ridge <- 1 - mape_ridge
accuracy_ridge #73.3%
```
## Lassso


```{r 'B30-10', eval=FALSE}

custom <- trainControl(method = "repeatedcv", number = 10, repeats = 5)
lasso <- train (price ~., train, method = "glmnet",
                tuneGrid = expand.grid(alpha = 1, lambda = seq(0.0001, 1, length = 5)), 
                trControl = custom)
#
```


```{r 'B30-11', eval=FALSE}
predicted_lasso <- predict(lasso, newdata = test)# predict the test data
table_lasso <- data.frame(Actual  = test$price, Predicted = predicted_lasso)#createa  table with actual test and predictd test
str(table_lasso)
```

```{r 'B30-12', eval=FALSE}

mape_lasso <- mean(abs(table_lasso$Actual - table_lasso$Predicted) / table_lasso$Actual)
accuracy_lasso <- 1 - mape_lasso
accuracy_lasso #73.7%
```


```{r 'B30-13', eval=FALSE}
accuracy_lasso
accuracy_ridge
accuracy_test
accuracy_els
```


## Elastic


```{r 'B30-14', eval=FALSE}
custom <- trainControl(method = "repeatedcv", number = 10, repeats = 5)
#lasso <- train (price ~., train, method = "glmnet",
                #tuneGrid = expand.grid(alpha = 1, lambda = seq(0.0001, 1, length = 5)), 
                #trControl = custom)
elastic <- train (price ~ ., train, method = "glmnet", 
                  tuneGrid = expand.grid(alpha = seq(0, 1, length = 10), 
                                         lambda = seq(0.0001, 1, length = 5)), trControl = custom)

predicted_els <- predict(elastic, newdata = test)# predict the test data
table_els <- data.frame(Actual  = test$price, Predicted = predicted_els)#createa  table with actual test and predictd test
str(table_els)
mape_els <- mean(abs(table_els$Actual - table_els$Predicted) / table_els$Actual)
accuracy_els <- 1 - mape_els
accuracy_els #73.7% 0.737696
```



## New Dataset Description

DATASET_2: This dataset provides features (related to demographics and buying behaviour) that are very relevant to predicting an auto insurance company's customer lifetime value (CLV)  . For more details about the features, see the dataset. 
	Following the given dataset, apply customer lifetime value as the target/dependent variable, use relevant features provided in the data as the independent variables, and develop predictive models. Considering the given situation as the regression problem, execute linear regression to predict the target variable. Use the results and provide necessary recommendations.
	
	

## Validation {.unlisted .unnumbered .tabset .tabset-fade}

```{r 'B30-Cleanup', include=FALSE, cache=FALSE}
f_rmExist(aa, bb, ii, jj, kk, ll)
```

```{r 'B30-Validation', include=FALSE, cache=FALSE}
# #SUMMARISED Packages and Objects (BOOK CHECK)
f_()
#
difftime(Sys.time(), k_start)
```

****
